
from utility import *
import numpy as np
import scipy.spatial as scp
import time
import math
from InitialRBFMatrices import InitialRBFMatrices
from Minimize_Merit_Function import Minimize_Merit_Function
from phi import phi
import os, shutil

import subprocess
#Min create this
import multiprocessing
from multiprocessing import Pool, Process
import importlib
import read_binary_file

##### Min created this for blaine ##################
def run_folders_parallel((wel_locate,wel_loc,da,wel_locate_o,num)):
    #num is number of processors using
    current = multiprocessing.current_process() #for each pool, only four continous four numbers could be
    p=os.getcwd()
    pp=os.getcwd()+'/proc/' # '/' using mac/linux(in windows should be '\\')
    if current._identity[0]%num==0:
        x=num
    else:
        x=current._identity[0]%num
    mypath=pp+str(x) 
    #change directory in to each folder and run the expensive function
    os.chdir(mypath)
    print 'da',da
    wel_locate1=os.getcwd()+'\\'+wel_locate
    # rewrite wel file,
    Q_total=change_well_sub(wel_locate1,wel_loc,da,wel_locate_o)

    
    # --Call MODFLOW2k ----------------------------------------------
    # os.system("cmf2k.exe")
    #subprocess.call(origWD+"/mf2005 UMA.nam > /dev/null",shell=True)
    os.system(os.getcwd()+"\\mf2k HJH_1996_2007_SUB.nam") # for mac
    
    # read result
    f_result=os.getcwd()+'\\HJH_1996_2007.sbs'
    nrow= 230
    ncol= 320
    nsp= 48
    all_sub = read_binary_file.read_binary_file(f_result,nrow,ncol,nsp)
    max_sub = np.max(all_sub[-1])
    sum_sub = np.sum(all_sub[-1])
    i,j=np.unravel_index(all_sub[-1].argmax(),all_sub[-1].shape) # in order to find the place of the maximum subsidence
    # objective function need be maximize (Pumping rate1 contains all negative value)
    c_v = 0.60430419 # 0.60430419,0.6249563694 is the critical value of subsidence, the maximum subsidence generated by Caoliang's model
    w1 = 10**7 # weight given to penalty function, at least 10**3 
    obj_f = Q_total+ w1*max(max_sub-c_v,0)
    print Q_total
    print max_sub-c_v
    time_start = time.time()
    ret_time = time.time() - time_start
    #change directory back in case of errors outside this function
    os.chdir(p)
    return da,max_sub-c_v,sum_sub,Q_total,obj_f

def change_well_sub(wel_file,well_name,pump_rate,wel_locate_o):
    pump_wel_file2=wel_file.split('.')[0]+str(1)+'.wel'
    if os.path.isfile(pump_wel_file2):
        os.remove(pump_wel_file2)
    with open(wel_locate_o) as flr:
        lines=flr.readlines() # read all information
    total_Q=0
    num_Q=0
    stress_period = 0
    #print 'pump_rate',pump_rate.shape
    for line in lines:
        arg=line.split(" ")
        if len(arg)==2:
            if int(arg[0])== 3833:
                stress_period=stress_period+1
        # if it's in the line with well info instead of other lines
        if len(arg)==6:
            if arg[-1][1:-2] in well_name: # the case of wells need to consider changing
                #indices = [x for x, elem in enumerate(well_name) if arg[-1][1:-2] in elem] #"indices" only have one element
                #indice = indices[0]
                #print pump_rate[0,indice],indice
                pr=pump_rate
                #if stress_period < 27: # there are a total 36 stress periods (48, but the middle two are the same), so just treat last 3 years independently
                if stress_period %3 ==2:
                    replaceExp = ' '.join(arg[0:3])+' '+str(pr)+' '+' '.join(arg[4:])
                    total_Q=total_Q+pr
                else:
                    replaceExp = ' '.join(arg[0:3])+' '+str(pr/2)+' '+' '.join(arg[4:])
                    total_Q=total_Q+pr/2
                
                num_Q=num_Q+1
                with open(pump_wel_file2,'a+') as flw:
                    flw.write(replaceExp) # read all information
            else: # the case of wells no need to consider changing
                with open(pump_wel_file2,'a+') as flw:
                    flw.write(line)
        else: # the case of other info as line "3833 0" 
            with open(pump_wel_file2,'a+') as flw:
                flw.write(line)
    # return an error
    print 'num_Q ',num_Q 
    #if num_Q != 576:
        #print "there is error in number of writing wells"
        #qqqqq
    # change name to be the one read by MODFLOW 
    if os.path.isfile(wel_file):
        os.remove(wel_file)
    os.rename(pump_wel_file2 ,wel_file)
    return total_Q
##### End created  ##################

if __name__ == '__main__':
    nprocs=8
    for i in range(1,nprocs+1):
        pp=os.getcwd()+'\\' # / is in mac need to change when using windows(should be '\\')
        mypath=pp+'proc\\'+str(i)
        if os.path.exists(mypath):
            pass
        else:
            if i==1: # for each folder only one copy of content
                src=pp+'proc\\'  #src=pp+'PYTHON'# yellowstone version
                shutil.copytree(os.getcwd(),os.getcwd()+'\\proc\\1')
            else:
                src=pp+'proc\\1'
                shutil.copytree(src,os.getcwd()+'\\proc\\'+str(i))
                
    #Pumping_rate1=np.array(range(-2000,-200,10))
    Pumping_rate_proc=np.array(range(-2000,-200,10*nprocs))
    len_pr_proc = Pumping_rate_proc.shape[0]
    print 'len_pr_proc'
    # read the file containing the 56 wells needed only and generate a list containing all well names
    wel_chosen=os.getcwd()+'\\pwel_chosen_for_T.wel'
    wel_loc=[]
    with open(wel_chosen) as flr:
        lines_wel=flr.readlines() # read all information
    for line in lines_wel:
        arg=line.split(" ") #split each
        if len(arg)==6:
            wel_loc.append(arg[-1][1:-2])
    wel_locate='HJH_1996_2007.wel'
    wel_locate_o=os.getcwd()+'\\HJH_1996_2007_origin.wel'
    print 'arraive here'
    pool = Pool(processes=nprocs) 
    for i in  range(len_pr_proc):
        if i != len_pr_proc-1:
            Q_total=pool.map(run_folders_parallel,((wel_locate,[wel_loc[2]],i,wel_locate_o,nprocs) for i in range(Pumping_rate_proc[i],Pumping_rate_proc[i+1],10)))
        else:
            Q_total=pool.map(run_folders_parallel,((wel_locate,[wel_loc[2]],i,wel_locate_o,nprocs) for i in range(Pumping_rate_proc[i],-200,10)))
        
        result_iter_filename = os.getcwd()+'\\result_linearity.txt'
        
        with open(result_iter_filename,'a+') as fid:
            for ii in range(len(Q_total)):
                print Q_total[ii][0],type(Q_total[ii][0]),\
                Q_total[ii][1],type(Q_total[ii][1]),\
                    Q_total[ii][2],type(Q_total[ii][2]),\
                    Q_total[ii][3],type(Q_total[ii][3]),\
                    Q_total[ii][4],type(Q_total[ii][4])
                fid.write('\n'+str('%-12f'%Q_total[ii][0])+' '+\
                    str('%12e'%Q_total[ii][1])+' '+\
                    str('%12e'%Q_total[ii][2])+' '+\
                    str('%12e'%Q_total[ii][3])+' '+\
                    str('%12e'%Q_total[ii][4]))#+' '+str('%12e'%result[ii][1]))
    pool.close()
    pool.join()    
